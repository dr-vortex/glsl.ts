// This is from https://www.khronos.org/registry/gles/specs/2.0/GLSL_ES_Specification_1.0.17.pdf
export let API_NAME = '<api>';
export let API =
	"\nimport {\n  // The variable `gl_Position` is available only in the vertex language and is intended for writing the\n  // homogeneous vertex position. This value will be used by primitive assembly, clipping, culling, and other\n  // fixed functionality operations that operate on primitives after vertex processing has occurred.\n  //\n  // All executions of a well-formed vertex shader should write a value into this variable. It can be\n  // written at any time during shader execution. It may also be read back by the shader after being written.\n  // Compilers may generate a diagnostic message if they detect `gl_Position` is not written, or read before\n  // being written, but not all such cases are detectable. The value of `gl_Position` is undefined if a vertex\n  // shader is executed and does not write `gl_Position`.\n  highp vec4 gl_Position;\n\n  // The variable `gl_PointSize` is available only in the vertex language and is intended for\n  // a vertex shader to write the size of the point to be rasterized. It is measured in pixels.\n  mediump float gl_PointSize;\n\n  const int gl_MaxVertexAttribs;\n  const int gl_MaxVertexUniformVectors;\n  const int gl_MaxVaryingVectors;\n  const int gl_MaxVertexTextureImageUnits;\n  const int gl_MaxCombinedTextureImageUnits;\n  const int gl_MaxTextureImageUnits;\n  const int gl_MaxFragmentUniformVectors;\n  const int gl_MaxDrawBuffers;\n\n  // The fragment shader has access to the read-only built-in variable `gl_FrontFacing` whose value is `true` if\n  // the fragment belongs to a front-facing primitive. One use of this is to emulate two-sided lighting by\n  // selecting one of two colors calculated by the vertex shader.\n  const bool gl_FrontFacing;\n\n  // The fragment shader has access to the read-only built-in variable `gl_PointCoord`. The values in\n  // `gl_PointCoord` are two-dimensional coordinates indicating where within a point primitive the current\n  // fragment is located. They range from 0.0 to 1.0 across the point. If the current primitive is not a\n  // point, then the values read from `gl_PointCoord` are undefined.\n  const mediump vec2 gl_PointCoord;\n\n  // The variable `gl_FragCoord` is available as a read-only variable from within fragment shaders and it holds\n  // the window relative coordinates `x`, `y`, `z`, and `1/w` values for the fragment. This value is the result\n  // of the fixed functionality that interpolates primitives after vertex processing to generate fragments. The `z`\n  // component is the depth value that will be used for the fragment's depth.\n  const mediump vec4 gl_FragCoord;\n\n  // Writing to `gl_FragColor` specifies the fragment color that will be used by the subsequent fixed\n  // functionality pipeline.\n  //\n  // If subsequent fixed functionality consumes fragment color and an execution of a fragment shader\n  // does not write a value to `gl_FragColor` then the fragment color consumed is undefined.\n  mediump vec4 gl_FragColor;\n\n  // The variable `gl_FragData` is an array. Writing to `gl_FragData[n]` specifies the fragment data that will be\n  // used by the subsequent fixed functionality pipeline for data `n`.\n  //\n  // If subsequent fixed functionality consumes fragment data and an execution of a fragment shader does not write\n  // a value to it, then the fragment data consumed is undefined.\n  mediump vec4 gl_FragData[gl_MaxDrawBuffers];\n\n  // Depth range in window coordinates\n  struct gl_DepthRangeParameters {\n    float near;\n    float far;\n    // Equal to `far - near`\n    float diff;\n  };\n\n  uniform gl_DepthRangeParameters gl_DepthRange;\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Angle and Trigonometry Functions\n\n  // Converts `degrees` to radians, i.e. `π / 180 * degrees`\n  float radians(float degrees);\n  // Converts `degrees` to radians, i.e. `π / 180 * degrees`\n  vec2 radians(vec2 degrees);\n  // Converts `degrees` to radians, i.e. `π / 180 * degrees`\n  vec3 radians(vec3 degrees);\n  // Converts `degrees` to radians, i.e. `π / 180 * degrees`\n  vec4 radians(vec4 degrees);\n\n  // Converts `radians` to degrees, i.e. `180 / π * radians`\n  float degrees(float radians);\n  // Converts `radians` to degrees, i.e. `180 / π * radians`\n  vec2 degrees(vec2 radians);\n  // Converts `radians` to degrees, i.e. `180 / π * radians`\n  vec3 degrees(vec3 radians);\n  // Converts `radians` to degrees, i.e. `180 / π * radians`\n  vec4 degrees(vec4 radians);\n\n  // The standard trigonometric sine function.\n  float sin(float angle);\n  // The standard trigonometric sine function.\n  vec2 sin(vec2 angle);\n  // The standard trigonometric sine function.\n  vec3 sin(vec3 angle);\n  // The standard trigonometric sine function.\n  vec4 sin(vec4 angle);\n\n  // The standard trigonometric cosine function.\n  float cos(float angle);\n  // The standard trigonometric cosine function.\n  vec2 cos(vec2 angle);\n  // The standard trigonometric cosine function.\n  vec3 cos(vec3 angle);\n  // The standard trigonometric cosine function.\n  vec4 cos(vec4 angle);\n\n  // The standard trigonometric tangent.\n  float tan(float angle);\n  // The standard trigonometric tangent.\n  vec2 tan(vec2 angle);\n  // The standard trigonometric tangent.\n  vec3 tan(vec3 angle);\n  // The standard trigonometric tangent.\n  vec4 tan(vec4 angle);\n\n  // Arc sine. Returns an angle whose sine is `x`. The range of values returned by this function is `[-π/2, π/2]`. Results are undefined if `∣x∣>1`.\n  float asin(float x);\n  // Arc sine. Returns an angle whose sine is `x`. The range of values returned by this function is `[-π/2, π/2]`. Results are undefined if `∣x∣>1`.\n  vec2 asin(vec2 x);\n  // Arc sine. Returns an angle whose sine is `x`. The range of values returned by this function is `[-π/2, π/2]`. Results are undefined if `∣x∣>1`.\n  vec3 asin(vec3 x);\n  // Arc sine. Returns an angle whose sine is `x`. The range of values returned by this function is `[-π/2, π/2]`. Results are undefined if `∣x∣>1`.\n  vec4 asin(vec4 x);\n\n  // Arc cosine. Returns an angle whose cosine is `x`. The range of values returned by this function is `[0, π]`. Results are undefined if `∣x∣>1`.\n  float acos(float x);\n  // Arc cosine. Returns an angle whose cosine is `x`. The range of values returned by this function is `[0, π]`. Results are undefined if `∣x∣>1`.\n  vec2 acos(vec2 x);\n  // Arc cosine. Returns an angle whose cosine is `x`. The range of values returned by this function is `[0, π]`. Results are undefined if `∣x∣>1`.\n  vec3 acos(vec3 x);\n  // Arc cosine. Returns an angle whose cosine is `x`. The range of values returned by this function is `[0, π]`. Results are undefined if `∣x∣>1`.\n  vec4 acos(vec4 x);\n\n  // Arc tangent. Returns an angle whose tangent is `y/x`. The signs of `x` and `y` are used to determine what quadrant the\n  // angle is in. The range of values returned by this function is `[−π,π]`. Results are undefined if `x` and `y` are both 0.\n  float atan(float y, float x);\n  // Arc tangent. Returns an angle whose tangent is `y/x`. The signs of `x` and `y` are used to determine what quadrant the\n  // angle is in. The range of values returned by this function is `[−π,π]`. Results are undefined if `x` and `y` are both 0.\n  vec2 atan(vec2 y, vec2 x);\n  // Arc tangent. Returns an angle whose tangent is `y/x`. The signs of `x` and `y` are used to determine what quadrant the\n  // angle is in. The range of values returned by this function is `[−π,π]`. Results are undefined if `x` and `y` are both 0.\n  vec3 atan(vec3 y, vec3 x);\n  // Arc tangent. Returns an angle whose tangent is `y/x`. The signs of `x` and `y` are used to determine what quadrant the\n  // angle is in. The range of values returned by this function is `[−π,π]`. Results are undefined if `x` and `y` are both 0.\n  vec4 atan(vec4 y, vec4 x);\n\n  // Arc tangent. Returns an angle whose tangent is `y_over_x`. The range of values returned by this function is `[-π/2, π/2]`.\n  float atan(float y_over_x);\n  // Arc tangent. Returns an angle whose tangent is `y_over_x`. The range of values returned by this function is `[-π/2, π/2]`.\n  vec2 atan(vec2 y_over_x);\n  // Arc tangent. Returns an angle whose tangent is `y_over_x`. The range of values returned by this function is `[-π/2, π/2]`.\n  vec3 atan(vec3 y_over_x);\n  // Arc tangent. Returns an angle whose tangent is `y_over_x`. The range of values returned by this function is `[-π/2, π/2]`.\n  vec4 atan(vec4 y_over_x);\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Exponential Functions\n\n  // Returns `x` raised to the `y` power, i.e., `xʸ`. Results are undefined if `x < 0`. Results are undefined if `x = 0` and `y <= 0`.\n  float pow(float x, float y);\n  // Returns `x` raised to the `y` power, i.e., `xʸ`. Results are undefined if `x < 0`. Results are undefined if `x = 0` and `y <= 0`.\n  vec2 pow(vec2 x, vec2 y);\n  // Returns `x` raised to the `y` power, i.e., `xʸ`. Results are undefined if `x < 0`. Results are undefined if `x = 0` and `y <= 0`.\n  vec3 pow(vec3 x, vec3 y);\n  // Returns `x` raised to the `y` power, i.e., `xʸ`. Results are undefined if `x < 0`. Results are undefined if `x = 0` and `y <= 0`.\n  vec4 pow(vec4 x, vec4 y);\n\n  // Returns the natural exponentiation of `x`, i.e., `eˣ`\n  float exp(float x);\n  // Returns the natural exponentiation of `x`, i.e., `eˣ`\n  vec2 exp(vec2 x);\n  // Returns the natural exponentiation of `x`, i.e., `eˣ`\n  vec3 exp(vec3 x);\n  // Returns the natural exponentiation of `x`, i.e., `eˣ`\n  vec4 exp(vec4 x);\n\n  // Returns the natural logarithm of `x`, i.e., returns the value `y` which satisfies the equation `x = eʸ`. Results are undefined if `x <= 0`.\n  float log(float x);\n  // Returns the natural logarithm of `x`, i.e., returns the value `y` which satisfies the equation `x = eʸ`. Results are undefined if `x <= 0`.\n  vec2 log(vec2 x);\n  // Returns the natural logarithm of `x`, i.e., returns the value `y` which satisfies the equation `x = eʸ`. Results are undefined if `x <= 0`.\n  vec3 log(vec3 x);\n  // Returns the natural logarithm of `x`, i.e., returns the value `y` which satisfies the equation `x = eʸ`. Results are undefined if `x <= 0`.\n  vec4 log(vec4 x);\n\n  // Returns 2 raised to the `x` power, i.e., `2ˣ`.\n  float exp2(float x);\n  // Returns 2 raised to the `x` power, i.e., `2ˣ`.\n  vec2 exp2(vec2 x);\n  // Returns 2 raised to the `x` power, i.e., `2ˣ`.\n  vec3 exp2(vec3 x);\n  // Returns 2 raised to the `x` power, i.e., `2ˣ`.\n  vec4 exp2(vec4 x);\n\n  // Returns the base 2 logarithm of `x`, i.e., returns the value `y` which satisfies the equation `x = 2ʸ`. Results are undefined if `x <= 0`.\n  float log2(float x);\n  // Returns the base 2 logarithm of `x`, i.e., returns the value `y` which satisfies the equation `x = 2ʸ`. Results are undefined if `x <= 0`.\n  vec2 log2(vec2 x);\n  // Returns the base 2 logarithm of `x`, i.e., returns the value `y` which satisfies the equation `x = 2ʸ`. Results are undefined if `x <= 0`.\n  vec3 log2(vec3 x);\n  // Returns the base 2 logarithm of `x`, i.e., returns the value `y` which satisfies the equation `x = 2ʸ`. Results are undefined if `x <= 0`.\n  vec4 log2(vec4 x);\n\n  // Returns `√x`. Results are undefined if `x < 0`.\n  float sqrt(float x);\n  // Returns `√x`. Results are undefined if `x < 0`.\n  vec2 sqrt(vec2 x);\n  // Returns `√x`. Results are undefined if `x < 0`.\n  vec3 sqrt(vec3 x);\n  // Returns `√x`. Results are undefined if `x < 0`.\n  vec4 sqrt(vec4 x);\n\n  // Returns `1 / √x`. Results are undefined if `x <= 0`.\n  float inversesqrt(float x);\n  // Returns `1 / √x`. Results are undefined if `x <= 0`.\n  vec2 inversesqrt(vec2 x);\n  // Returns `1 / √x`. Results are undefined if `x <= 0`.\n  vec3 inversesqrt(vec3 x);\n  // Returns `1 / √x`. Results are undefined if `x <= 0`.\n  vec4 inversesqrt(vec4 x);\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Common Functions\n\n  // Returns `x` if `x >= 0`, otherwise it returns `-x`.\n  float abs(float x);\n  // Returns `x` if `x >= 0`, otherwise it returns `-x`.\n  vec2 abs(vec2 x);\n  // Returns `x` if `x >= 0`, otherwise it returns `-x`.\n  vec3 abs(vec3 x);\n  // Returns `x` if `x >= 0`, otherwise it returns `-x`.\n  vec4 abs(vec4 x);\n\n  // Returns `1.0` if `x > 0`, `0.0` if `x = 0`, or `-1.0` if `x < 0`\n  float sign(float x);\n  // Returns `1.0` if `x > 0`, `0.0` if `x = 0`, or `-1.0` if `x < 0`\n  vec2 sign(vec2 x);\n  // Returns `1.0` if `x > 0`, `0.0` if `x = 0`, or `-1.0` if `x < 0`\n  vec3 sign(vec3 x);\n  // Returns `1.0` if `x > 0`, `0.0` if `x = 0`, or `-1.0` if `x < 0`\n  vec4 sign(vec4 x);\n\n  // Returns a value equal to the nearest integer that is less than or equal to `x`\n  float floor(float x);\n  // Returns a value equal to the nearest integer that is less than or equal to `x`\n  vec2 floor(vec2 x);\n  // Returns a value equal to the nearest integer that is less than or equal to `x`\n  vec3 floor(vec3 x);\n  // Returns a value equal to the nearest integer that is less than or equal to `x`\n  vec4 floor(vec4 x);\n\n  // Returns a value equal to the nearest integer that is greater than or equal to `x`\n  float ceil(float x);\n  // Returns a value equal to the nearest integer that is greater than or equal to `x`\n  vec2 ceil(vec2 x);\n  // Returns a value equal to the nearest integer that is greater than or equal to `x`\n  vec3 ceil(vec3 x);\n  // Returns a value equal to the nearest integer that is greater than or equal to `x`\n  vec4 ceil(vec4 x);\n\n  // Returns `x - floor(x)`\n  float fract(float x);\n  // Returns `x - floor(x)`\n  vec2 fract(vec2 x);\n  // Returns `x - floor(x)`\n  vec3 fract(vec3 x);\n  // Returns `x - floor(x)`\n  vec4 fract(vec4 x);\n\n  // Modulus (modulo). Returns `x - y * floor(x/y)`\n  float mod(float x, float y);\n  // Modulus (modulo). Returns `x - y * floor(x/y)`\n  vec2 mod(vec2 x, float y);\n  // Modulus (modulo). Returns `x - y * floor(x/y)`\n  vec3 mod(vec3 x, float y);\n  // Modulus (modulo). Returns `x - y * floor(x/y)`\n  vec4 mod(vec4 x, float y);\n\n  // Modulus. Returns `x - y * floor(x/y)`\n  vec2 mod(vec2 x, vec2 y);\n  // Modulus. Returns `x - y * floor(x/y)`\n  vec3 mod(vec3 x, vec3 y);\n  // Modulus. Returns `x - y * floor(x/y)`\n  vec4 mod(vec4 x, vec4 y);\n\n  // Returns `y` if `y < x`, otherwise it returns `x`\n  float min(float x, float y);\n  // Returns `y` if `y < x`, otherwise it returns `x`\n  vec2 min(vec2 x, float y);\n  // Returns `y` if `y < x`, otherwise it returns `x`\n  vec2 min(vec2 x, vec2 y);\n  // Returns `y` if `y < x`, otherwise it returns `x`\n  vec3 min(vec3 x, float y);\n  // Returns `y` if `y < x`, otherwise it returns `x`\n  vec3 min(vec3 x, vec3 y);\n  // Returns `y` if `y < x`, otherwise it returns `x`\n  vec4 min(vec4 x, float y);\n  // Returns `y` if `y < x`, otherwise it returns `x`\n  vec4 min(vec4 x, vec4 y);\n\n  // Returns `y` if `x < y`, otherwise it returns `x`\n  float max(float x, float y);\n  // Returns `y` if `x < y`, otherwise it returns `x`\n  vec2 max(vec2 x, float y);\n  // Returns `y` if `x < y`, otherwise it returns `x`\n  vec2 max(vec2 x, vec2 y);\n  // Returns `y` if `x < y`, otherwise it returns `x`\n  vec3 max(vec3 x, float y);\n  // Returns `y` if `x < y`, otherwise it returns `x`\n  vec3 max(vec3 x, vec3 y);\n  // Returns `y` if `x < y`, otherwise it returns `x`\n  vec4 max(vec4 x, float y);\n  // Returns `y` if `x < y`, otherwise it returns `x`\n  vec4 max(vec4 x, vec4 y);\n\n  // Returns `min(max(x, minVal), maxVal)`. Results are undefined if `minVal > maxVal`.\n  float clamp(float x, float minVal, float maxVal);\n  // Returns `min(max(x, minVal), maxVal)`. Results are undefined if `minVal > maxVal`.\n  vec2 clamp(vec2 x, float minVal, float maxVal);\n  // Returns `min(max(x, minVal), maxVal)`. Results are undefined if `minVal > maxVal`.\n  vec2 clamp(vec2 x, vec2 minVal, vec2 maxVal);\n  // Returns `min(max(x, minVal), maxVal)`. Results are undefined if `minVal > maxVal`.\n  vec3 clamp(vec3 x, float minVal, float maxVal);\n  // Returns `min(max(x, minVal), maxVal)`. Results are undefined if `minVal > maxVal`.\n  vec3 clamp(vec3 x, vec3 minVal, vec3 maxVal);\n  // Returns `min(max(x, minVal), maxVal)`. Results are undefined if `minVal > maxVal`.\n  vec4 clamp(vec4 x, float minVal, float maxVal);\n  // Returns `min(max(x, minVal), maxVal)`. Results are undefined if `minVal > maxVal`.\n  vec4 clamp(vec4 x, vec4 minVal, vec4 maxVal);\n\n  // Returns the linear blend of `x` and `y`, i.e. `x * (1-a) + y * a`\n  float mix(float x, float y, float a);\n  // Returns the linear blend of `x` and `y`, i.e. `x * (1-a) + y * a`\n  vec2 mix(vec2 x, vec2 y, float a);\n  // Returns the linear blend of `x` and `y`, i.e. `x * (1-a) + y * a`\n  vec2 mix(vec2 x, vec2 y, vec2 a);\n  // Returns the linear blend of `x` and `y`, i.e. `x * (1-a) + y * a`\n  vec3 mix(vec3 x, vec3 y, float a);\n  // Returns the linear blend of `x` and `y`, i.e. `x * (1-a) + y * a`\n  vec3 mix(vec3 x, vec3 y, vec3 a);\n  // Returns the linear blend of `x` and `y`, i.e. `x * (1-a) + y * a`\n  vec4 mix(vec4 x, vec4 y, float a);\n  // Returns the linear blend of `x` and `y`, i.e. `x * (1-a) + y * a`\n  vec4 mix(vec4 x, vec4 y, vec4 a);\n\n  // Returns `0.0` if `x < edge`, otherwise it returns `1.0`\n  float step(float edge, float x);\n  // Returns `0.0` if `x < edge`, otherwise it returns `1.0`\n  vec2 step(float edge, vec2 x);\n  // Returns `0.0` if `x < edge`, otherwise it returns `1.0`\n  vec2 step(vec2 edge, vec2 x);\n  // Returns `0.0` if `x < edge`, otherwise it returns `1.0`\n  vec3 step(float edge, vec3 x);\n  // Returns `0.0` if `x < edge`, otherwise it returns `1.0`\n  vec3 step(vec3 edge, vec3 x);\n  // Returns `0.0` if `x < edge`, otherwise it returns `1.0`\n  vec4 step(float edge, vec4 x);\n  // Returns `0.0` if `x < edge`, otherwise it returns `1.0`\n  vec4 step(vec4 edge, vec4 x);\n\n  // Returns `0.0` if `x <= edge0` and `1.0` if `x >= edge1` and performs smooth Hermite interpolation between 0 and 1 when `edge0 < x < edge1`.\n  // This is useful in cases where you would want a threshold function with a smooth transition. This is equivalent to:\n  //\n  // ```glslx\n  // float t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n  // return t * t * (3.0 - 2.0 * t);\n  // ```\n  //\n  // Results are undefined if `edge0 >= edge1`.\n  float smoothstep(float edge0, float edge1, float x);\n  // Returns `0.0` if `x <= edge0` and `1.0` if `x >= edge1` and performs smooth Hermite interpolation between 0 and 1 when `edge0 < x < edge1`.\n  // This is useful in cases where you would want a threshold function with a smooth transition. This is equivalent to:\n  //\n  // ```glslx\n  // vec2 t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n  // return t * t * (3.0 - 2.0 * t);\n  // ```\n  //\n  // Results are undefined if `edge0 >= edge1`.\n  vec2 smoothstep(float edge0, float edge1, vec2 x);\n  // Returns `0.0` if `x <= edge0` and `1.0` if `x >= edge1` and performs smooth Hermite interpolation between 0 and 1 when `edge0 < x < edge1`.\n  // This is useful in cases where you would want a threshold function with a smooth transition. This is equivalent to:\n  //\n  // ```glslx\n  // vec2 t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n  // return t * t * (3.0 - 2.0 * t);\n  // ```\n  //\n  // Results are undefined if `edge0 >= edge1`.\n  vec2 smoothstep(vec2 edge0, vec2 edge1, vec2 x);\n  // Returns `0.0` if `x <= edge0` and `1.0` if `x >= edge1` and performs smooth Hermite interpolation between 0 and 1 when `edge0 < x < edge1`.\n  // This is useful in cases where you would want a threshold function with a smooth transition. This is equivalent to:\n  //\n  // ```glslx\n  // vec3 t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n  // return t * t * (3.0 - 2.0 * t);\n  // ```\n  //\n  // Results are undefined if `edge0 >= edge1`.\n  vec3 smoothstep(float edge0, float edge1, vec3 x);\n  // Returns `0.0` if `x <= edge0` and `1.0` if `x >= edge1` and performs smooth Hermite interpolation between 0 and 1 when `edge0 < x < edge1`.\n  // This is useful in cases where you would want a threshold function with a smooth transition. This is equivalent to:\n  //\n  // ```glslx\n  // vec3 t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n  // return t * t * (3.0 - 2.0 * t);\n  // ```\n  //\n  // Results are undefined if `edge0 >= edge1`.\n  vec3 smoothstep(vec3 edge0, vec3 edge1, vec3 x);\n  // Returns `0.0` if `x <= edge0` and `1.0` if `x >= edge1` and performs smooth Hermite interpolation between 0 and 1 when `edge0 < x < edge1`.\n  // This is useful in cases where you would want a threshold function with a smooth transition. This is equivalent to:\n  //\n  // ```glslx\n  // vec4 t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n  // return t * t * (3.0 - 2.0 * t);\n  // ```\n  //\n  // Results are undefined if `edge0 >= edge1`.\n  vec4 smoothstep(float edge0, float edge1, vec4 x);\n  // Returns `0.0` if `x <= edge0` and `1.0` if `x >= edge1` and performs smooth Hermite interpolation between 0 and 1 when `edge0 < x < edge1`.\n  // This is useful in cases where you would want a threshold function with a smooth transition. This is equivalent to:\n  //\n  // ```glslx\n  // vec4 t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n  // return t * t * (3.0 - 2.0 * t);\n  // ```\n  //\n  // Results are undefined if `edge0 >= edge1`.\n  vec4 smoothstep(vec4 edge0, vec4 edge1, vec4 x);\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Geometric Functions\n\n  // Returns the length of vector `x`, i.e. `√x²`\n  float length(float x);\n  // Returns the length of vector `x`, i.e. `√x[0]² + x[1]²`\n  float length(vec2 x);\n  // Returns the length of vector `x`, i.e. `√x[0]² + x[1]² + x[2]²`\n  float length(vec3 x);\n  // Returns the length of vector `x`, i.e. `√x[0]² + x[1]² + x[2]² + x[3]²`\n  float length(vec4 x);\n\n  // Returns the distance between `p0` and `p1`, i.e. `length(p0 - p1)`\n  float distance(float p0, float p1);\n  // Returns the distance between `p0` and `p1`, i.e. `length(p0 - p1)`\n  float distance(vec2 p0, vec2 p1);\n  // Returns the distance between `p0` and `p1`, i.e. `length(p0 - p1)`\n  float distance(vec3 p0, vec3 p1);\n  // Returns the distance between `p0` and `p1`, i.e. `length(p0 - p1)`\n  float distance(vec4 p0, vec4 p1);\n\n  // Returns the dot product of `x` and `y`, i.e. `x*y`\n  float dot(float x, float y);\n  // Returns the dot product of `x` and `y`, i.e. `x[0]*y[0] + x[1]*y[1]`\n  float dot(vec2 x, vec2 y);\n  // Returns the dot product of `x` and `y`, i.e. `x[0]*y[0] + x[1]*y[1] + x[2]*y[2]`\n  float dot(vec3 x, vec3 y);\n  // Returns the dot product of `x` and `y`, i.e. `x[0]*y[0] + x[1]*y[1] + x[2]*y[2] + x[3]*y[3]`\n  float dot(vec4 x, vec4 y);\n\n  // Returns the cross product of `x` and `y`, i.e.\n  //\n  // ```glslx\n  // vec3(\n  //   x[1]*y[2] - y[1]*x[2],\n  //   x[2]*y[0] - y[2]*x[0],\n  //   x[0]*y[1] - y[0]*x[1])\n  // ```\n  vec3 cross(vec3 x, vec3 y);\n\n  // Returns a vector in the same direction as `x` but with a length of 1.\n  float normalize(float x);\n  // Returns a vector in the same direction as `x` but with a length of 1.\n  vec2 normalize(vec2 x);\n  // Returns a vector in the same direction as `x` but with a length of 1.\n  vec3 normalize(vec3 x);\n  // Returns a vector in the same direction as `x` but with a length of 1.\n  vec4 normalize(vec4 x);\n\n  // If `dot(Nref, I) < 0` return `N`, otherwise return `-N`\n  float faceforward(float N, float I, float Nref);\n  // If `dot(Nref, I) < 0` return `N`, otherwise return `-N`\n  vec2 faceforward(vec2 N, vec2 I, vec2 Nref);\n  // If `dot(Nref, I) < 0` return `N`, otherwise return `-N`\n  vec3 faceforward(vec3 N, vec3 I, vec3 Nref);\n  // If `dot(Nref, I) < 0` return `N`, otherwise return `-N`\n  vec4 faceforward(vec4 N, vec4 I, vec4 Nref);\n\n  // For the incident vector `I` and surface orientation `N`, returns the reflection direction: `I - 2 * dot(N, I) * N`.\n  // `N` must already be normalized in order to achieve the desired result.\n  float reflect(float I, float N);\n  // For the incident vector `I` and surface orientation `N`, returns the reflection direction: `I - 2 * dot(N, I) * N`.\n  // `N` must already be normalized in order to achieve the desired result.\n  vec2 reflect(vec2 I, vec2 N);\n  // For the incident vector `I` and surface orientation `N`, returns the reflection direction: `I - 2 * dot(N, I) * N`.\n  // `N` must already be normalized in order to achieve the desired result.\n  vec3 reflect(vec3 I, vec3 N);\n  // For the incident vector `I` and surface orientation `N`, returns the reflection direction: `I - 2 * dot(N, I) * N`.\n  // `N` must already be normalized in order to achieve the desired result.\n  vec4 reflect(vec4 I, vec4 N);\n\n  // For the incident vector `I` and surface normal `N`, and the ratio of indices of refraction `eta`, return the refraction vector.\n  // The result is computed by:\n  //\n  // ```glslx\n  // float k = 1.0 - eta * eta * (1.0 - dot(N, I) * dot(N, I));\n  // if (k < 0.0) return float(0.0);\n  // else return eta * I - (eta * dot(N, I) + sqrt(k)) * N;\n  // ```\n  //\n  // The input parameters for the incident vector `I` and the surface normal `N`.\n  float refract(float I, float N, float eta);\n  // For the incident vector `I` and surface normal `N`, and the ratio of indices of refraction `eta`, return the refraction vector.\n  // The result is computed by:\n  //\n  // ```glslx\n  // float k = 1.0 - eta * eta * (1.0 - dot(N, I) * dot(N, I));\n  // if (k < 0.0) return vec2(0.0);\n  // else return eta * I - (eta * dot(N, I) + sqrt(k)) * N;\n  // ```\n  //\n  // The input parameters for the incident vector `I` and the surface normal `N`.\n  vec2 refract(vec2 I, vec2 N, float eta);\n  // For the incident vector `I` and surface normal `N`, and the ratio of indices of refraction `eta`, return the refraction vector.\n  // The result is computed by:\n  //\n  // ```glslx\n  // float k = 1.0 - eta * eta * (1.0 - dot(N, I) * dot(N, I));\n  // if (k < 0.0) return vec3(0.0);\n  // else return eta * I - (eta * dot(N, I) + sqrt(k)) * N;\n  // ```\n  //\n  // The input parameters for the incident vector `I` and the surface normal `N`.\n  vec3 refract(vec3 I, vec3 N, float eta);\n  // For the incident vector `I` and surface normal `N`, and the ratio of indices of refraction `eta`, return the refraction vector.\n  // The result is computed by:\n  //\n  // ```glslx\n  // float k = 1.0 - eta * eta * (1.0 - dot(N, I) * dot(N, I));\n  // if (k < 0.0) return vec4(0.0);\n  // else return eta * I - (eta * dot(N, I) + sqrt(k)) * N;\n  // ```\n  //\n  // The input parameters for the incident vector `I` and the surface normal `N`.\n  vec4 refract(vec4 I, vec4 N, float eta);\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Matrix Functions\n\n  // Multiply matrix `x` by matrix `y` component-wise, i.e., `result[i][j]` is the scalar product of `x[i][j]` and `y[i][j]`.\n  // Note: to get linear algebraic matrix multiplication, use the multiply operator (`*`).\n  mat2 matrixCompMult(mat2 x, mat2 y);\n  // Multiply matrix `x` by matrix `y` component-wise, i.e., `result[i][j]` is the scalar product of `x[i][j]` and `y[i][j]`.\n  // Note: to get linear algebraic matrix multiplication, use the multiply operator (`*`).\n  mat3 matrixCompMult(mat3 x, mat3 y);\n  // Multiply matrix `x` by matrix `y` component-wise, i.e., `result[i][j]` is the scalar product of `x[i][j]` and `y[i][j]`.\n  // Note: to get linear algebraic matrix multiplication, use the multiply operator (`*`).\n  mat4 matrixCompMult(mat4 x, mat4 y);\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Vector Relational Functions\n\n  // Returns the component-wise compare of `x < y`.\n  bvec2 lessThan(ivec2 x, ivec2 y);\n  // Returns the component-wise compare of `x < y`.\n  bvec2 lessThan(vec2 x, vec2 y);\n  // Returns the component-wise compare of `x < y`.\n  bvec3 lessThan(ivec3 x, ivec3 y);\n  // Returns the component-wise compare of `x < y`.\n  bvec3 lessThan(vec3 x, vec3 y);\n  // Returns the component-wise compare of `x < y`.\n  bvec4 lessThan(ivec4 x, ivec4 y);\n  // Returns the component-wise compare of `x < y`.\n  bvec4 lessThan(vec4 x, vec4 y);\n\n  // Returns the component-wise compare of `x <= y`.\n  bvec2 lessThanEqual(ivec2 x, ivec2 y);\n  // Returns the component-wise compare of `x <= y`.\n  bvec2 lessThanEqual(vec2 x, vec2 y);\n  // Returns the component-wise compare of `x <= y`.\n  bvec3 lessThanEqual(ivec3 x, ivec3 y);\n  // Returns the component-wise compare of `x <= y`.\n  bvec3 lessThanEqual(vec3 x, vec3 y);\n  // Returns the component-wise compare of `x <= y`.\n  bvec4 lessThanEqual(ivec4 x, ivec4 y);\n  // Returns the component-wise compare of `x <= y`.\n  bvec4 lessThanEqual(vec4 x, vec4 y);\n\n  // Returns the component-wise compare of `x > y`.\n  bvec2 greaterThan(ivec2 x, ivec2 y);\n  // Returns the component-wise compare of `x > y`.\n  bvec2 greaterThan(vec2 x, vec2 y);\n  // Returns the component-wise compare of `x > y`.\n  bvec3 greaterThan(ivec3 x, ivec3 y);\n  // Returns the component-wise compare of `x > y`.\n  bvec3 greaterThan(vec3 x, vec3 y);\n  // Returns the component-wise compare of `x > y`.\n  bvec4 greaterThan(ivec4 x, ivec4 y);\n  // Returns the component-wise compare of `x > y`.\n  bvec4 greaterThan(vec4 x, vec4 y);\n\n  // Returns the component-wise compare of `x >= y`.\n  bvec2 greaterThanEqual(ivec2 x, ivec2 y);\n  // Returns the component-wise compare of `x >= y`.\n  bvec2 greaterThanEqual(vec2 x, vec2 y);\n  // Returns the component-wise compare of `x >= y`.\n  bvec3 greaterThanEqual(ivec3 x, ivec3 y);\n  // Returns the component-wise compare of `x >= y`.\n  bvec3 greaterThanEqual(vec3 x, vec3 y);\n  // Returns the component-wise compare of `x >= y`.\n  bvec4 greaterThanEqual(ivec4 x, ivec4 y);\n  // Returns the component-wise compare of `x >= y`.\n  bvec4 greaterThanEqual(vec4 x, vec4 y);\n\n  // Returns the component-wise compare of `x == y`.\n  bvec2 equal(bvec2 x, bvec2 y);\n  // Returns the component-wise compare of `x == y`.\n  bvec2 equal(ivec2 x, ivec2 y);\n  // Returns the component-wise compare of `x == y`.\n  bvec2 equal(vec2 x, vec2 y);\n  // Returns the component-wise compare of `x == y`.\n  bvec3 equal(bvec3 x, bvec3 y);\n  // Returns the component-wise compare of `x == y`.\n  bvec3 equal(ivec3 x, ivec3 y);\n  // Returns the component-wise compare of `x == y`.\n  bvec3 equal(vec3 x, vec3 y);\n  // Returns the component-wise compare of `x == y`.\n  bvec4 equal(bvec4 x, bvec4 y);\n  // Returns the component-wise compare of `x == y`.\n  bvec4 equal(ivec4 x, ivec4 y);\n  // Returns the component-wise compare of `x == y`.\n  bvec4 equal(vec4 x, vec4 y);\n\n  // Returns the component-wise compare of `x != y`.\n  bvec2 notEqual(bvec2 x, bvec2 y);\n  // Returns the component-wise compare of `x != y`.\n  bvec2 notEqual(ivec2 x, ivec2 y);\n  // Returns the component-wise compare of `x != y`.\n  bvec2 notEqual(vec2 x, vec2 y);\n  // Returns the component-wise compare of `x != y`.\n  bvec3 notEqual(bvec3 x, bvec3 y);\n  // Returns the component-wise compare of `x != y`.\n  bvec3 notEqual(ivec3 x, ivec3 y);\n  // Returns the component-wise compare of `x != y`.\n  bvec3 notEqual(vec3 x, vec3 y);\n  // Returns the component-wise compare of `x != y`.\n  bvec4 notEqual(bvec4 x, bvec4 y);\n  // Returns the component-wise compare of `x != y`.\n  bvec4 notEqual(ivec4 x, ivec4 y);\n  // Returns the component-wise compare of `x != y`.\n  bvec4 notEqual(vec4 x, vec4 y);\n\n  // Returns true if any component of `x` is `true`.\n  bool any(bvec2 x);\n  // Returns true if any component of `x` is `true`.\n  bool any(bvec3 x);\n  // Returns true if any component of `x` is `true`.\n  bool any(bvec4 x);\n\n  // Returns true only if all components of `x` are `true`.\n  bool all(bvec2 x);\n  // Returns true only if all components of `x` are `true`.\n  bool all(bvec3 x);\n  // Returns true only if all components of `x` are `true`.\n  bool all(bvec4 x);\n\n  // Returns the component-wise logical complement of `x`.\n  bvec2 not(bvec2 x);\n  // Returns the component-wise logical complement of `x`.\n  bvec3 not(bvec3 x);\n  // Returns the component-wise logical complement of `x`.\n  bvec4 not(bvec4 x);\n\n  ////////////////////////////////////////////////////////////////////////////////\n  // Texture Lookup Functions\n\n  // Use the texture coordinate `coord` to do a texture lookup in the 2D texture currently bound to `sampler`.\n  vec4 texture2D(sampler2D sampler, vec2 coord);\n  // Use the texture coordinate `coord` to do a texture lookup in the 2D texture currently bound to `sampler`.\n  vec4 texture2D(sampler2D sampler, vec2 coord, float bias);\n  // Use the texture coordinate `coord` to do a texture lookup in the 2D texture currently bound to `sampler`.\n  vec4 texture2DLod(sampler2D sampler, vec2 coord, float lod);\n  // Use the texture coordinate `coord` to do a texture lookup in the 2D texture currently bound to `sampler`.\n  // The texture coordinate `(coord.s, coord.t)` is divided by the last component of `coord`.\n  vec4 texture2DProj(sampler2D sampler, vec3 coord);\n  // Use the texture coordinate `coord` to do a texture lookup in the 2D texture currently bound to `sampler`.\n  // The texture coordinate `(coord.s, coord.t)` is divided by the last component of `coord`.\n  vec4 texture2DProj(sampler2D sampler, vec3 coord, float bias);\n  // Use the texture coordinate `coord` to do a texture lookup in the 2D texture currently bound to `sampler`.\n  // The texture coordinate `(coord.s, coord.t)` is divided by the last component of `coord`.\n  vec4 texture2DProjLod(sampler2D sampler, vec3 coord, float lod);\n  // Use the texture coordinate `coord` to do a texture lookup in the 2D texture currently bound to `sampler`.\n  // The texture coordinate `(coord.s, coord.t)` is divided by the last component of `coord`. The third component of `coord` is ignored.\n  vec4 texture2DProj(sampler2D sampler, vec4 coord);\n  // Use the texture coordinate `coord` to do a texture lookup in the 2D texture currently bound to `sampler`.\n  // The texture coordinate `(coord.s, coord.t)` is divided by the last component of `coord`. The third component of `coord` is ignored.\n  vec4 texture2DProj(sampler2D sampler, vec4 coord, float bias);\n  // Use the texture coordinate `coord` to do a texture lookup in the 2D texture currently bound to `sampler`.\n  // The texture coordinate `(coord.s, coord.t)` is divided by the last component of `coord`. The third component of `coord` is ignored.\n  vec4 texture2DProjLod(sampler2D sampler, vec4 coord, float lod);\n\n  // Use the texture coordinate `coord` to do a texture lookup in the cube map texture currently bound to `sampler`.\n  // The direction of `coord` is used to select which face to do a 2-dimensional texture lookup in.\n  vec4 textureCube(samplerCube sampler, vec3 coord);\n  // Use the texture coordinate `coord` to do a texture lookup in the cube map texture currently bound to `sampler`.\n  // The direction of `coord` is used to select which face to do a 2-dimensional texture lookup in.\n  vec4 textureCube(samplerCube sampler, vec3 coord, float bias);\n  // Use the texture coordinate `coord` to do a texture lookup in the cube map texture currently bound to `sampler`.\n  // The direction of `coord` is used to select which face to do a 2-dimensional texture lookup in.\n  vec4 textureCubeLod(samplerCube sampler, vec3 coord, float lod);\n\n  #extension GL_OES_standard_derivatives {\n    // Available only in the fragment shader, this function returns the partial derivative of expression `p` with respect to the window `x` coordinate.\n    //\n    // Expressions that imply higher order derivatives such as `dFdx(dFdx(n))` have undefined results, as do mixed-order derivatives such as\n    // `dFdx(dFdy(n))`. It is assumed that the expression `p` is continuous and therefore, expressions evaluated via non-uniform control flow may be undefined.\n    float dFdx(float v);\n    // Available only in the fragment shader, this function returns the partial derivative of expression `p` with respect to the window `x` coordinate.\n    //\n    // Expressions that imply higher order derivatives such as `dFdx(dFdx(n))` have undefined results, as do mixed-order derivatives such as\n    // `dFdx(dFdy(n))`. It is assumed that the expression `p` is continuous and therefore, expressions evaluated via non-uniform control flow may be undefined.\n    vec2 dFdx(vec2 v);\n    // Available only in the fragment shader, this function returns the partial derivative of expression `p` with respect to the window `x` coordinate.\n    //\n    // Expressions that imply higher order derivatives such as `dFdx(dFdx(n))` have undefined results, as do mixed-order derivatives such as\n    // `dFdx(dFdy(n))`. It is assumed that the expression `p` is continuous and therefore, expressions evaluated via non-uniform control flow may be undefined.\n    vec3 dFdx(vec3 v);\n    // Available only in the fragment shader, this function returns the partial derivative of expression `p` with respect to the window `x` coordinate.\n    //\n    // Expressions that imply higher order derivatives such as `dFdx(dFdx(n))` have undefined results, as do mixed-order derivatives such as\n    // `dFdx(dFdy(n))`. It is assumed that the expression `p` is continuous and therefore, expressions evaluated via non-uniform control flow may be undefined.\n    vec4 dFdx(vec4 v);\n\n    // Available only in the fragment shader, this function returns the partial derivative of expression `p` with respect to the window `y` coordinate.\n    //\n    // Expressions that imply higher order derivatives such as `dFdy(dFdy(n))` have undefined results, as do mixed-order derivatives such as\n    // `dFdx(dFdy(n))`. It is assumed that the expression `p` is continuous and therefore, expressions evaluated via non-uniform control flow may be undefined.\n    float dFdy(float v);\n    // Available only in the fragment shader, this function returns the partial derivative of expression `p` with respect to the window `y` coordinate.\n    //\n    // Expressions that imply higher order derivatives such as `dFdy(dFdy(n))` have undefined results, as do mixed-order derivatives such as\n    // `dFdx(dFdy(n))`. It is assumed that the expression `p` is continuous and therefore, expressions evaluated via non-uniform control flow may be undefined.\n    vec2 dFdy(vec2 v);\n    // Available only in the fragment shader, this function returns the partial derivative of expression `p` with respect to the window `y` coordinate.\n    //\n    // Expressions that imply higher order derivatives such as `dFdy(dFdy(n))` have undefined results, as do mixed-order derivatives such as\n    // `dFdx(dFdy(n))`. It is assumed that the expression `p` is continuous and therefore, expressions evaluated via non-uniform control flow may be undefined.\n    vec3 dFdy(vec3 v);\n    // Available only in the fragment shader, this function returns the partial derivative of expression `p` with respect to the window `y` coordinate.\n    //\n    // Expressions that imply higher order derivatives such as `dFdy(dFdy(n))` have undefined results, as do mixed-order derivatives such as\n    // `dFdx(dFdy(n))`. It is assumed that the expression `p` is continuous and therefore, expressions evaluated via non-uniform control flow may be undefined.\n    vec4 dFdy(vec4 v);\n\n    // Returns the sum of the absolute derivative in `x` and `y` using local differencing for the input argument `p`, i.e. `abs(dFdx(p)) + abs(dFdy(p))`\n    float fwidth(float v);\n    // Returns the sum of the absolute derivative in `x` and `y` using local differencing for the input argument `p`, i.e. `abs(dFdx(p)) + abs(dFdy(p))`\n    vec2 fwidth(vec2 v);\n    // Returns the sum of the absolute derivative in `x` and `y` using local differencing for the input argument `p`, i.e. `abs(dFdx(p)) + abs(dFdy(p))`\n    vec3 fwidth(vec3 v);\n    // Returns the sum of the absolute derivative in `x` and `y` using local differencing for the input argument `p`, i.e. `abs(dFdx(p)) + abs(dFdy(p))`\n    vec4 fwidth(vec4 v);\n  }\n\n  #extension GL_EXT_frag_depth {\n    // Available only in the fragment language, `gl_FragDepthEXT` is an output variable that is used to establish the depth value for the current fragment.\n    // If depth buffering is enabled and no shader writes to `gl_FragDepthEXT`, then the fixed function value for depth will be used (this value is contained\n    // in the `z` component of `gl_FragCoord`) otherwise, the value written to `gl_FragDepthEXT` is used.\n    //\n    // If a shader statically assigns to `gl_FragDepthEXT`, then the value of the fragment's depth may be undefined for executions of the shader that take\n    // that path. That is, if the set of linked fragment shaders statically contain a write to `gl_FragDepthEXT`, then it is responsible for always writing it.\n    float gl_FragDepthEXT;\n  }\n\n  #extension GL_EXT_shader_texture_lod {\n    vec4 texture2DGradEXT(sampler2D sampler, vec2 P, vec2 dPdx, vec2 dPdy);\n    vec4 texture2DLodEXT(sampler2D sampler, vec2 coord, float lod);\n    vec4 texture2DProjGradEXT(sampler2D sampler, vec3 P, vec2 dPdx, vec2 dPdy);\n    vec4 texture2DProjGradEXT(sampler2D sampler, vec4 P, vec2 dPdx, vec2 dPdy);\n    vec4 texture2DProjLodEXT(sampler2D sampler, vec3 coord, float lod);\n    vec4 texture2DProjLodEXT(sampler2D sampler, vec4 coord, float lod);\n    vec4 textureCubeGradEXT(samplerCube sampler, vec3 P, vec3 dPdx, vec3 dPdy);\n    vec4 textureCubeLodEXT(samplerCube sampler, vec3 coord, float lod);\n  }\n}\n";
